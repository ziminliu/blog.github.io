<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker 环境Hadoop 安装教程</title>
    <link href="/2020/03/03/Docker%E9%83%A8%E7%BD%B2Hadoop/"/>
    <url>/2020/03/03/Docker%E9%83%A8%E7%BD%B2Hadoop/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-环境Hadoop-安装教程"><a href="#Docker-环境Hadoop-安装教程" class="headerlink" title="Docker 环境Hadoop 安装教程"></a>Docker 环境Hadoop 安装教程</h1><h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h2><p>docker 拉取的最新Ubuntu镜像</p><h2 id="2-更改镜像源"><a href="#2-更改镜像源" class="headerlink" title="2. 更改镜像源"></a>2. 更改镜像源</h2><ol><li><p>复制原来的源信息</p><pre><code>$ cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></pre></li><li><p>安装vim</p><p>docker中的Ubuntu镜像默认没有vim 因此需要先安装vim,可使用以下命令，由于是从国外服务器下载，可能会有点慢。</p><pre><code>$ apt-get install vim</code></pre></li><li><p>修改源文件</p><pre><code>$ vim /etc/apt/sources.list</code></pre><p>将源文件中的内容换成</p><pre><code>deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre></li><li><p>更新软件列表</p><pre><code>$ apt-get update</code></pre></li><li><p>更新软件包</p><pre><code>$apt-get upgrade</code></pre></li></ol><h2 id="3-安装SSH、配置SSH-无密码登录"><a href="#3-安装SSH、配置SSH-无密码登录" class="headerlink" title="3. 安装SSH、配置SSH 无密码登录"></a>3. 安装SSH、配置SSH 无密码登录</h2><p>由于我们已经更改的镜像源，所以我们可以很快的安装SSH的相关服务</p><p>安装SSH client</p><pre><code>$ apt-get install openssh-client</code></pre><p>安装SSH server</p><pre><code>$ apt-get install openssh-server</code></pre><p>安装完成之后我们需要启动SSH服务</p><pre><code>$ service ssh start</code></pre><p>可以用以下命令查看SSH 服务的状态</p><pre><code>$ service ssh status</code></pre><p>如果正常启动，则会显示</p><pre><code> * sshd is running</code></pre><p>我们使用<code>ssh localhost</code>登录时会每次都要输入密码，因此我们现在将SSH配置成无密码登录，输入以下命令</p><pre><code>$ cd ~/.ssh/                     # 进入该目录，若没有则创建$ ssh-keygen -t rsa              # 输入后一直按回车就可以$ cat ./id_rsa.pub &gt;&gt; ./authorized_keys  # 将生成的秘钥加入授权</code></pre><p>之后我们就可以直接输入 <code>ssh localhost</code>登录了</p><h2 id="4-安装Java环境"><a href="#4-安装Java环境" class="headerlink" title="4. 安装Java环境"></a>4. 安装Java环境</h2><ol><li><p>下载jdk</p><pre><code>$ apt-get install default-jre default-jdk</code></pre></li><li><p>添加环境变量</p><pre><code>$ vim ~/.bashrc</code></pre><p>将以下语句添加至文件第一行</p><pre><code>export JAVA_HOME=/usr/lib/jvm/default-java</code></pre></li><li><p>更新环境变量</p><pre><code>$ source ~/.bashrc</code></pre></li><li><p>检查是否生效</p><pre><code>$ echo $JAVA_HOME     # 打印环境变量的值$ java -version          # 显示jdk 版本</code></pre></li></ol><h2 id="5-安装Hadoop-2"><a href="#5-安装Hadoop-2" class="headerlink" title="5. 安装Hadoop 2"></a>5. 安装Hadoop 2</h2><ol><li><p>在宿主机中先下载好Hadoop的压缩包，我这里下载的是<code>hadoop-2.8.5.tar.gz</code>放在了 <code>H</code>盘的根目录下。</p></li><li><p>将宿主机中的安装包拷贝至容器中，我这里的容器名叫做Hadoop</p><p>命令行启动，输入以下命令</p><pre><code>&gt; docker cp H:/hadoop-2.8.5.tar.gz hadoop:/windows/</code></pre></li><li><p>解压压缩包</p><pre><code>$ tar -zxf /windows/hadoop-2.8.5.tar.gz -C /usr/local</code></pre></li><li><p>进入安装目录</p><pre><code>$ cd /usr/local/</code></pre></li><li><p>修改文件名</p><pre><code>$ mv ./hadoop-2.8.5 ./hadoop</code></pre></li><li><p>执行文件查看版本信息</p><p>先进入hadoop目录，然后执行下列语句</p><pre><code>$ ./bin/hadoop version</code></pre><p>会出现以下信息则说明安装成功</p><pre><code>Hadoop 2.8.5Subversion https://git-wip-us.apache.org/repos/asf/hadoop.git -r 0b8464d75227fcee2c6e7f2410377b3d53d3d5f8Compiled by jdu on 2018-09-10T03:32ZCompiled with protoc 2.5.0From source with checksum 9942ca5c745417c14e318835f420733This command was run using /usr/local/hadoop/share/hadoop/common/hadoop-common-2.8.5.jar</code></pre></li></ol><h2 id="6-Hadoop-伪分布式配置"><a href="#6-Hadoop-伪分布式配置" class="headerlink" title="6. Hadoop 伪分布式配置"></a>6. Hadoop 伪分布式配置</h2><ol><li><p>修改Hadoop的配置文件</p><ol><li><p>core-site.xml</p><p>进入<code>/usr/local/hadoop/etc/hadoop/</code></p><pre><code>$ cd /usr/local/hadoop/etc/hadoop$ vim core-site.xml</code></pre><p>将其中的</p><pre><code>&lt;configuration&gt;&lt;/configuration&gt;</code></pre><p>修改为</p><pre><code>&lt;configuration&gt;        &lt;property&gt;                &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;                                                       &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt;                &lt;description&gt;Abase for other temporary directories.&lt;/description&gt;        &lt;/property&gt;                                                                       &lt;property&gt;                &lt;name&gt;fs.defaultFS&lt;/name&gt;                &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;        &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>保存退出</p></li><li><p>hdfs-site.xml</p><p>同样在<code>configuratio</code> 标签修改为</p><pre><code>&lt;configuration&gt;        &lt;property&gt;                &lt;name&gt;dfs.replication&lt;/name&gt;                &lt;value&gt;1&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;                &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;                &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt;        &lt;/property&gt;&lt;/configuration&gt;</code></pre></li></ol></li><li><p>执行<code>NAMENode</code>的格式化</p><pre><code>$ cd /usr/local/hadoop$ ./bin/hdfs namenode -format</code></pre><p>成功会显示</p><pre><code>Exitting with status 0”</code></pre></li><li><p>开启<code>NameNode</code>和<code>DataNode</code>守护进程</p><pre><code>$ cd /usr/local/hadoop$ ./sbin/start-dfs.sh</code></pre></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>都9102年了，你还只会用python爬虫吗？</title>
    <link href="/2019/12/03/9102%E7%88%AC%E8%99%AB/"/>
    <url>/2019/12/03/9102%E7%88%AC%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="都9102年了，你还只会用python爬虫吗？"><a href="#都9102年了，你还只会用python爬虫吗？" class="headerlink" title="都9102年了，你还只会用python爬虫吗？"></a>都9102年了，你还只会用python爬虫吗？</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>无聊的时候，我们总会打开豆瓣电影榜，从上到下刷着电影，仿佛那些经典台词马上就在我们耳边响起，如《肖申克的救赎》中：生活可以归结为一种简单的选择：不是忙于生存，就是赶着去死；《霸王别姬》中：说的是一辈子！差一年，一个月，一天，一个时辰，都不算一辈子！但是，豆瓣电影那么多，还有那么多页，一页一页的找岂不是太费时间了，今天我就来从前端的角度来爬取豆瓣电影榜top250的首页。<a href="https://movie.douban.com/top250" target="_blank" rel="noopener">豆瓣top250</a>  </p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-获取豆瓣首页的html"><a href="#1-获取豆瓣首页的html" class="headerlink" title="1. 获取豆瓣首页的html"></a>1. 获取豆瓣首页的html</h3><p>由于我们需要向豆瓣的服务器发送一个请求来得到豆瓣首页的html代码，请求与响应在网络传输中需要一定的时间，而后续的操作需要在这个响应的基础上进行，因此，我们需要将主函数定义为异步的。以上实现需要引入下面两个包(注意：request 是对等依赖，需要与request-promise 分开安装）  </p><pre><code class="javascript">    npm i request    npm i request-promise  </code></pre><pre><code class="javascript">    let request = require(&#39;request-promise&#39;)    const main = async() =&gt; {      let html = await request({        url: &#39;https://movie.douban.com/top250&#39;      })      console.log(html)    }    main();</code></pre><h3 id="2-对html结构分析"><a href="#2-对html结构分析" class="headerlink" title="2.对html结构分析"></a>2.对html结构分析</h3><p>这样，我们就得到了豆瓣首页的html代码，但是我们需要的只是很少的一部分信息，所以我们要对其中的信息进行提取，因此我们引入一个npm包cheerio来提取html 特定选择器中的文本内容   </p><pre><code class="javascript">    npm i cherrio  </code></pre><p>然后在第二行引入</p><pre><code class="javascript">    let cheerio = require(&#39;cheerio&#39;);</code></pre><p>接下来我们要做的就是利用cheerio 将得到的html文本载入内存构建DOM，并使用选择器对目标标签中的文本进行提取，因此我们需要分析豆瓣首页的html结构</p><p><img src="./content.png" srcset="/img/loading.gif" alt="alt content"><br>content中是我们需要的内容，gird-16-8 用于设置主体内容的布局，article是电影项的主体部分，我们需要的内容就在其中，aside 置于网页右侧放置醒目信息，extra用于清除两端浮动。现在让我们进入article中看看   </p><p><img src="./article.png" srcset="/img/loading.gif" alt="alt article"><br>我们可以看到是一个典型的head,body,foot结构<br>opt mod   内放置一个复选框，用于用户选择根据条件筛选<br>grid_view  提取内容的主体<br>paginator  页尾的分页导航<br>进入grid_view，我们所需要的内容都放置在一个一个的列表中,列表中的每一个item都是一个我们需要提取的一部电影。     </p><h3 id="3-使用选择器得到需要的内容"><a href="#3-使用选择器得到需要的内容" class="headerlink" title="3.使用选择器得到需要的内容"></a>3.使用选择器得到需要的内容</h3><p>根据上面我们对结构的分析，我们就可以使用下列语句得到我们选择器内的每一个item</p><pre><code class="javascript">let movieNodes = $(&#39;#content .article .grid_view&#39;).find(&#39;.item&#39;);</code></pre><p>然后我们对保存了所有item的这样一个数组遍历，将其中每一项的关键值提取出来并保存，选择器的构建方法与上述的item获得的方法一致</p><pre><code class="javascript">let movies = [];for (let i = 0; i &lt; movieNodes.length; i++) {    let $ = cheerio.load(movieNodes[i]);    let titles = $(&#39;.info .hd span&#39;);    titles = ([]).map.call(titles, t =&gt; $(t).text());    let bd = $(&#39;.info .bd&#39;);    let info = bd.find(&#39;p&#39;).text();    let score = bd.find(&#39;.star .rating_num&#39;).text();    movies.push({      &#39;titles&#39;: titles,      &#39;info&#39;: info,      &#39;score&#39;: score    })  }</code></pre><p>不同的是，由于.hd 的选择器下面有四个span,因此我们得到的是一个对象数组，我们不能直接进行提取否则会出现对象循环引用的错误，我们先使用map对空数组的每一个元素进行映射，然后再通过改变this指针，使用选择器对空数组中每一个元素进行赋值。然后将提取出来的每一个字段append到数组中。</p><h3 id="4-文件保存"><a href="#4-文件保存" class="headerlink" title="4.文件保存"></a>4.文件保存</h3><p>接下来，我们在第三行加上</p><pre><code class="javascript">let fs = require(&#39;fs&#39;);</code></pre><blockquote><blockquote><p>在for循环的外面继续补充</p></blockquote></blockquote><pre><code class="javascript">fs.writeFile(&#39;./mainjs.json&#39;, JSON.stringify(movies), &#39;utf-8&#39;, (err) =&gt; {    if (err)      console.log(&#39;写入失败&#39;);    else      console.log(&#39;写入成功&#39;);  });</code></pre><p>就可以将我们刚刚在存在数组中的数据以json格式写入文件中啦，打开这个文件就会发现豆瓣top250的首页内容就存到了这个文件中，我们就可以挑选自己喜欢的电影观看了。<br>现在，让我们回过头来看看豆瓣top250首页的页面结构  </p><p><img src="./douban.jpg" srcset="/img/loading.gif" alt="body"><br>body豆瓣的首页由100%的body占据，body又分为上中下三部分，每个版块又按照一定的功能再划分为相应的子模块，直到划分为一个最小的模块为止，每一个模块占据网页的一定位置，实现某一个特定的功能，每个模块之间互不干扰。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对豆瓣的爬取，我们知道了，如果一个网站的结构带有一定规律，并有良好的可读性，会让我们的爬取更加简单，相反，如果一个网站乱糟糟的，毫无章法可言，那么这样的网站简直就是灾难。因此，我们在今后的编程中，应当多看看一些大型网站的html代码，学习其中的结构设计和命名规范。然后我们可以使用<a href="http://getbem.com/" target="_blank" rel="noopener">BEM</a>(Block Element Modifier)命名规范，对每一个模块使用合适的选择器，这样不仅提高了代码的可重用行，也利于网站的管理和维护。 </p><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><p>暑假闲来无事看了点python视频，虽然已经忘得都差不多了，但是用了node爬取了一次，又让我又拾起的对python的热情，于是一番折腾，查了相关文档，终于给捣鼓出来了，毕竟，生命在于折腾嘛！<br>以下是python的爬虫方式,基本思路与上述爬虫方式类似，只是对数据处理的语法上有所差异：<br>需要安转requests和beautifulsoup4模块</p><pre><code>pip install requestspip install beautifulsoup4</code></pre><pre><code class="python">import requestsfrom bs4 import BeautifulSoupimport jsondef gettext(x):     return x.get_text()#设置请求头伪装header = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36&#39;}# 先使用requests发送网络请求从而获取网页html = requests.get(&#39;https://movie.douban.com/top250&#39;, headers=header)# print(html.status_code)# 传入html构建DOMsoup=BeautifulSoup(html.content,&#39;html.parser&#39;)movieNodes = soup.find(&#39;ol&#39;, attrs={&#39;class&#39;: &#39;grid_view&#39;})movies=[]for movie in movieNodes.find_all(&#39;li&#39;):    title=movie.find(&#39;div&#39;,attrs={&#39;class&#39;:&#39;hd&#39;})    titles=title.find_all(&#39;span&#39;)    titles1=map(gettext,titles)    tit=[]    for ti in titles1:      tit.append(ti)    info=movie.find(&#39;p&#39;).get_text()    score=movie.find(&#39;span&#39;,attrs={&#39;class&#39;:&#39;rating_num&#39;}).get_text()    movies.append({      &quot;titles&quot;: tit,      &quot;info&quot;: info,      &quot;score&quot;: score    })f = open(&quot;mainpy.json&quot;, &quot;w&quot;, encoding=&#39;utf-8&#39;)json.dump(movies, f, ensure_ascii=False)f.close()</code></pre><p>写的时候遇到了以下这些小问题</p><ol><li>爬取豆瓣首页时，打印不出来html源码，查了一下才想起来是豆瓣做了反爬措施，需要伪装一下请求头信息。所以以后我们在爬取网站的时候可以先打印一下状态码status_code，如果显示418就说明被屏蔽了，显示200就说明请求成功。</li><li>使用find_all时，返回的是一个object数组，需要使用map方法提取出item 中每一个span的内容，然后添加到数组中去。map方法的使用可以查看相关的文档，里面有对每一个参数具体说明。</li><li>写文件的时候，报错说不能写入一个list,必须写入一个字符串，然后我将这个数组转成字符串写入文件，结果里面对转义字符没有进行转义，多了’\xa0’,’\n’ 等，查了一下发现这个玩意儿’\xa0’竟然就是html中的’&amp;nbsp’,然后我就用replace把每一个这个字符给删掉，结果存是存进去了，文件全爆红色，对比了mainjs.json才发现，保存的文件mainpy.json不是一个Json类型的数据，然后又是一顿度娘，发现有个专门写json文件的api,json.dump()，然后我replace直接也不用写了，不过需要引入json库….<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2>可能有时候写程序就是这样，出一个问题然后你就去解决这个问题，然后又出现另外的问题，你又得想怎么去解决新出现的问题，然后一直一直….结果发现直接使用一个api就好了…但是写程序注重的是过程，bug是我们编程道路上的补品，我们不能做一个apier，不是吗？</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim</title>
    <link href="/2018/03/03/Vim/"/>
    <url>/2018/03/03/Vim/</url>
    
    <content type="html"><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h2 id="1-vim的三种模式"><a href="#1-vim的三种模式" class="headerlink" title="1.vim的三种模式"></a>1.vim的三种模式</h2><h2 id="2-命令模式"><a href="#2-命令模式" class="headerlink" title="2.命令模式"></a>2.命令模式</h2><ol><li>按 <code>Esc</code>进入命令模式</li></ol><h2 id="3-插入模式"><a href="#3-插入模式" class="headerlink" title="3.插入模式"></a>3.插入模式</h2><p>进入插入模式的几种方法</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>i</td><td>在光标左侧插入</td></tr><tr><td>I</td><td>在光标所在行首插入</td></tr><tr><td>a</td><td>在光标右侧插入</td></tr><tr><td>A</td><td>在行尾插入</td></tr><tr><td>o</td><td>在光标所在行下方插入新的一行</td></tr><tr><td>O</td><td>在光标所在行的上方插入新的一行</td></tr></tbody></table><h2 id="4-底线插入模式"><a href="#4-底线插入模式" class="headerlink" title="4.底线插入模式"></a>4.底线插入模式</h2><p>命令模式下输入<code>:</code>进入</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>:wq</td><td>保存并退出</td></tr><tr><td>:w</td><td>保存不退出</td></tr><tr><td>:q</td><td>退出编辑</td></tr><tr><td>:q!</td><td>强制退出,不保存文件,</td></tr><tr><td>ZZ</td><td>保存文件,退出编辑</td></tr></tbody></table><h2 id="5-命令模式下各命令的具体作用"><a href="#5-命令模式下各命令的具体作用" class="headerlink" title="5.命令模式下各命令的具体作用"></a>5.命令模式下各命令的具体作用</h2><h3 id="5-1文本修改"><a href="#5-1文本修改" class="headerlink" title="5.1文本修改"></a>5.1文本修改</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>x</td><td>删除光标位置字符</td></tr><tr><td>dd</td><td>删除所在行</td></tr><tr><td>u</td><td>撤销最近修改</td></tr><tr><td>U</td><td>撤销当前行上的所有修改</td></tr><tr><td>r</td><td>替换光标位置上的一个字符</td></tr><tr><td>.</td><td>重复上一次的修改</td></tr></tbody></table><h3 id="5-2光标移动"><a href="#5-2光标移动" class="headerlink" title="5.2光标移动"></a>5.2光标移动</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>h</td><td>光标左移</td></tr><tr><td>j</td><td>光标下移</td></tr><tr><td>k</td><td>光标上移</td></tr><tr><td>l</td><td>光标右移</td></tr><tr><td>0(零)</td><td>光标移动到当前行行首</td></tr><tr><td>$</td><td>光标移动到当前行行尾</td></tr><tr><td>w</td><td>光标右移一个字</td></tr><tr><td>b</td><td>光标左移一个字</td></tr><tr><td>e</td><td>光标移到字尾</td></tr><tr><td>[Enter]</td><td>光标移动到下一行行首</td></tr><tr><td>[Space]</td><td>光标右移一位</td></tr><tr><td>[Backspace]</td><td>光标左移一位</td></tr></tbody></table><h3 id="5-3复制与粘贴"><a href="#5-3复制与粘贴" class="headerlink" title="5.3复制与粘贴"></a>5.3复制与粘贴</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>v</td><td>进入visual,选中文本</td></tr><tr><td>d</td><td>删除选中文本并复制到缓冲区</td></tr><tr><td>y</td><td>将选中文本并复制到缓冲区</td></tr><tr><td>p</td><td>将指定缓冲区的内容放到当前光标的位置右侧</td></tr><tr><td>P</td><td>将指定缓冲区的内容放到当前光标的位置左侧</td></tr></tbody></table><h3 id="5-4翻页"><a href="#5-4翻页" class="headerlink" title="5.4翻页"></a>5.4翻页</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>[ctrl+d]</td><td>将光标向下移到文件尾，通常每次移动12行</td></tr><tr><td>[ctrl+u]</td><td>将光标向上移到文件头，通常每次移动12行</td></tr><tr><td>[ctrl+f]</td><td>将光标向下移到文件尾，通常每次移动24行</td></tr><tr><td>[ctrl+b]</td><td>将光标向上移到文件头，通常每次移动24行</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
