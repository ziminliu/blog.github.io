<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入剖析ElementUI Alert组件</title>
    <link href="/2020/03/05/ElementUI-Alert/"/>
    <url>/2020/03/05/ElementUI-Alert/</url>
    
    <content type="html"><![CDATA[<h1 id="深入剖析ElementUI-Alert组件"><a href="#深入剖析ElementUI-Alert组件" class="headerlink" title="深入剖析ElementUI Alert组件"></a>深入剖析ElementUI Alert组件</h1><h2 id="邂逅Alert"><a href="#邂逅Alert" class="headerlink" title="邂逅Alert"></a>邂逅Alert</h2><p>ElementUI 作为国内比较火的一个VUe框架，主要原因是其中的数组件满足了日常开发的大部分需求，在写Vue项目的时候，经常会用Alert 组件与用户进行交互。作为一名在Vue学习之路上的后生小辈，源码分析可以提高我们项目开发的意识，今天我就来解剖一下ElementUI 中的Alert组件，在分析它的源码之前，让我们先看看它完整的功能有哪些？<a href="https://element.eleme.cn/#/zh-CN/component/alert" target="_blank" rel="noopener">ElementUI-Alert</a></p><h2 id="熟悉Alert"><a href="#熟悉Alert" class="headerlink" title="熟悉Alert"></a>熟悉Alert</h2><p>看完Alert的参数，我们大概可以知道Alert 的一些功能，它可以设置主题，标题，类型，图标，居中效果，是否可关闭，关闭按钮自定义文本文本，关闭触发的事件。写下来我们就开始解剖Alert组件</p><h2 id="Alert的结构分析"><a href="#Alert的结构分析" class="headerlink" title="Alert的结构分析"></a>Alert的结构分析</h2><ol><li>transition 显示变换效果</li><li>外层div盒子用于处理Alert整体的居中情况</li><li>i标签用于显示Alert的图标样式</li><li>内层div 展示Alert 的主体内容区域</li><li>span 标签用于设置alert的标题</li><li>两个p标签用于展示描述信息</li><li>最后的i标签用于显示关闭按钮或关闭文本</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p>Vue提供了封装的transition组件，在进入/离开的过程中，会产生6个类，通过6个类的样式切换可以实现简单的动画效果。具体可查阅<a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener">官网</a></p><p><img src="https://www.runoob.com/wp-content/uploads/2018/06/transition.png" srcset="/img/loading.gif" alt="transition"></p><p>我们找到 node_modules 里找到element-ui/lib/theme-chalk/alert.css，其中涉及到transition的样式有</p><pre><code class="css">.el-alert-fade-enter,.el-alert-fade-leave-active {  opacity: 0}</code></pre><p>只是简单的改变透明度，没有其他的样式改变。</p><h3 id="div"><a href="#div" class="headerlink" title="div"></a>div</h3><p>对于一般组件来说，组件的整体布局效果，都由外层盒子决定，这里也不意外，盒子的样式，以及居中效果都由这个div 决定</p><pre><code class="html">&lt;div      class=&quot;el-alert&quot;      :class=&quot;[typeClass, center ? &#39;is-center&#39; : &#39;&#39;, &#39;is-&#39; + effect]&quot;      v-show=&quot;visible&quot;      role=&quot;alert&quot;    &gt;</code></pre><p>这里的class 设置了盒子的默认样式，并且将一个数组绑定给力class，以应用此数组中的多个样式。现在然我们看看对应的一些参数</p><pre><code class="js">  props: {    type: {      type: String,      default: &quot;info&quot;    },    center: Boolean,    effect: {      type: String,      default: &quot;light&quot;,      validator: function(value) {        return [&quot;light&quot;, &quot;dark&quot;].indexOf(value) !== -1;      }    }  },  data() {      return {        visible: true      };    },  computed: {    typeClass() {      return `el-alert--${this.type}`;    }  }</code></pre><p>通过参数type 的值(success/warning/info/error)，使用typeClass 计算属性计算出相应的类名，应用对应的样式。以及center,effect 属性，effect参数增加了validator 方法验证参数值，对于值的要求更为严格，若不在数组当中，不仅不会应用样式，还会报错。可以看到，到Alert 被调用是，visible的初始值就被赋予了true，对于role属性，在我们的日常开发中用的很少，role的作用是供有障碍的人士使用的，从这里可以好的好的框架应用的群体更加广泛。</p><h3 id="i-图标"><a href="#i-图标" class="headerlink" title="i    图标"></a>i    图标</h3><p>i 标签的原作用本是改变文本样式，使文本斜体，但是由于在应用中非常少见，而图标的大量出现，使得i标签被icon 化。</p><pre><code class="html">&lt;i class=&quot;el-alert__icon&quot; :class=&quot;[ iconClass, isBigIcon ]&quot; v-if=&quot;showIcon&quot;&gt;&lt;/i&gt;</code></pre><pre><code class="js">  props: {    showIcon: Boolean  },  computed: {    iconClass() {      return TYPE_CLASSES_MAP[this.type] || &quot;el-icon-info&quot;;    },    isBigIcon() {      return this.description || this.$slots.default ? &quot;is-big&quot; : &quot;&quot;;    }  }</code></pre><pre><code class="js">&lt;script&gt;const TYPE_CLASSES_MAP = {    &#39;success&#39;: &#39;el-icon-success&#39;,    &#39;warning&#39;: &#39;el-icon-warning&#39;,    &#39;error&#39;: &#39;el-icon-error&#39;  };export default{    ...}&lt;/script&gt;</code></pre><p>此处根据show-icon  的属性值，来判断是否需要渲染图标，当条件为真时，根据type属性的值计算得到相应类型的图标。计算图标方法中使用了逻辑或运算符，即从左往右运算开始，当出现第一个属性真值为true,则返回当前值，不再进行后续的逻辑运算。此种方法，将 <code>el-icon-info</code>作为了默认图标。我们可以发现，只要我们开启了图标，即将show-icon 置为true，不论我们type 输入什么，图标等还是会出现，只是由于type的错误类型导致某些样式没有启用，而出现的视觉差异。isBigIcon 方法根据description的属性值或者插槽中的文本进行计算，当二者至少有一个为真时则渲染大图标。</p><h3 id="div-1"><a href="#div-1" class="headerlink" title="div"></a>div</h3><pre><code class="css">.el-alert__content {  display: table-cell;  padding: 0 8px}</code></pre><h3 id="span-标题"><a href="#span-标题" class="headerlink" title="span    标题"></a>span    标题</h3><p>此处渲染alert 框title的文本</p><pre><code class="html">&lt;span class=&quot;el-alert__title&quot; :class=&quot;[ isBoldTitle ]&quot; v-if=&quot;title || $slots.title&quot;&gt;          &lt;slot name=&quot;title&quot;&gt;{{ title }}&lt;/slot&gt;&lt;/span&gt;</code></pre><pre><code class="js">  props: {    title: {      type: String,      default: &quot;&quot;    }  },  computed: {         isBoldTitle() {        return this.description || this.$slots.default ? &#39;is-bold&#39; : &#39;&#39;;      }  }</code></pre><pre><code class="css">.el-alert__title {  font-size  : 13px;  line-height: 18px}.el-alert__title.is-bold {  font-weight: 700}</code></pre><p>此处通过使用了$slots API ，来得到插槽中的值，从而确定title是否显示，当描述信息存在时，则标题为粗体。</p><h3 id="p-描述信息"><a href="#p-描述信息" class="headerlink" title="p    描述信息"></a>p    描述信息</h3><pre><code class="html">&lt;p class=&quot;el-alert__description&quot; v-if=&quot;$slots.default &amp;&amp; !description&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/p&gt;&lt;p class=&quot;el-alert__description&quot; v-if=&quot;description &amp;&amp; !$slots.default&quot;&gt;{{ description }}&lt;/p&gt;</code></pre><p>此处放置两个p 标签来渲染描述信息，第一个为当描述信息以插槽的形式出现时渲染，第二个为当描述信息以属性的方式在组件内部出现时渲染，因此，当组件内部和插槽中都出现了描述信息时，都不渲染描述信息。</p><h3 id="i-关闭按钮-文本"><a href="#i-关闭按钮-文本" class="headerlink" title="i    关闭按钮/文本"></a>i    关闭按钮/文本</h3><pre><code class="html">&lt;i class=&quot;el-alert__closebtn&quot; :class=&quot;{ &#39;is-customed&#39;: closeText !== &#39;&#39;, &#39;el-icon-close&#39;: closeText === &#39;&#39; }&quot; v-show=&quot;closable&quot; @click=&quot;close()&quot;&gt;{{closeText}}&lt;/i&gt;</code></pre><pre><code class="js">  props: {    closable: {      type: Boolean,      default: true    },    closeText: {      type: String,      default: &quot;&quot;    }  },  methods: {    close() {      this.visible = false;      this.$emit(&quot;close&quot;);    }  }</code></pre><p>这里使用对象语法绑定class ,根据对象内属性的true or false 应用不同的css ，同时绑定了一个close的事件。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>作为一名刚上路的新手，第一眼看上去，感觉源码非常的复杂，但是，当仔细看进去了之后，发现其实也不难理解，通过源码的分析，我们不仅能够加深对Vue的理解，还能够帮助我们优化代码结构，培养业务能力。</p><blockquote><p>萌新上路，请多多指教</p><p>如有错误，欢迎指出</p></blockquote><p>饿了吗？有一说一，确实饿了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>ElementUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 环境Hadoop 安装教程</title>
    <link href="/2020/03/03/Docker%E9%83%A8%E7%BD%B2Hadoop/"/>
    <url>/2020/03/03/Docker%E9%83%A8%E7%BD%B2Hadoop/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-环境Hadoop-安装教程"><a href="#Docker-环境Hadoop-安装教程" class="headerlink" title="Docker 环境Hadoop 安装教程"></a>Docker 环境Hadoop 安装教程</h1><h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h2><p>docker 拉取的最新Ubuntu镜像</p><h2 id="2-更改镜像源"><a href="#2-更改镜像源" class="headerlink" title="2. 更改镜像源"></a>2. 更改镜像源</h2><ol><li><p>复制原来的源信息</p><pre><code>$ cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></pre></li><li><p>安装vim</p><p>docker中的Ubuntu镜像默认没有vim 因此需要先安装vim,可使用以下命令，由于是从国外服务器下载，可能会有点慢。</p><pre><code>$ apt-get install vim</code></pre></li><li><p>修改源文件</p><pre><code>$ vim /etc/apt/sources.list</code></pre><p>将源文件中的内容换成</p><pre><code>deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre></li><li><p>更新软件列表</p><pre><code>$ apt-get update</code></pre></li><li><p>更新软件包</p><pre><code>$apt-get upgrade</code></pre></li></ol><h2 id="3-安装SSH、配置SSH-无密码登录"><a href="#3-安装SSH、配置SSH-无密码登录" class="headerlink" title="3. 安装SSH、配置SSH 无密码登录"></a>3. 安装SSH、配置SSH 无密码登录</h2><p>由于我们已经更改的镜像源，所以我们可以很快的安装SSH的相关服务</p><p>安装SSH client</p><pre><code>$ apt-get install openssh-client</code></pre><p>安装SSH server</p><pre><code>$ apt-get install openssh-server</code></pre><p>安装完成之后我们需要启动SSH服务</p><pre><code>$ service ssh start</code></pre><p>可以用以下命令查看SSH 服务的状态</p><pre><code>$ service ssh status</code></pre><p>如果正常启动，则会显示</p><pre><code> * sshd is running</code></pre><p>我们使用<code>ssh localhost</code>登录时会每次都要输入密码，因此我们现在将SSH配置成无密码登录，输入以下命令</p><pre><code>$ cd ~/.ssh/                     # 进入该目录，若没有则创建$ ssh-keygen -t rsa              # 输入后一直按回车就可以$ cat ./id_rsa.pub &gt;&gt; ./authorized_keys  # 将生成的秘钥加入授权</code></pre><p>之后我们就可以直接输入 <code>ssh localhost</code>登录了</p><h2 id="4-安装Java环境"><a href="#4-安装Java环境" class="headerlink" title="4. 安装Java环境"></a>4. 安装Java环境</h2><ol><li><p>下载jdk</p><pre><code>$ apt-get install default-jre default-jdk</code></pre></li><li><p>添加环境变量</p><pre><code>$ vim ~/.bashrc</code></pre><p>将以下语句添加至文件第一行</p><pre><code>export JAVA_HOME=/usr/lib/jvm/default-java</code></pre></li><li><p>更新环境变量</p><pre><code>$ source ~/.bashrc</code></pre></li><li><p>检查是否生效</p><pre><code>$ echo $JAVA_HOME     # 打印环境变量的值$ java -version          # 显示jdk 版本</code></pre></li></ol><h2 id="5-安装Hadoop-2"><a href="#5-安装Hadoop-2" class="headerlink" title="5. 安装Hadoop 2"></a>5. 安装Hadoop 2</h2><ol><li><p>在宿主机中先下载好Hadoop的压缩包，我这里下载的是<code>hadoop-2.8.5.tar.gz</code>放在了 <code>H</code>盘的根目录下。</p></li><li><p>将宿主机中的安装包拷贝至容器中，我这里的容器名叫做Hadoop</p><p>命令行启动，输入以下命令</p><pre><code>&gt; docker cp H:/hadoop-2.8.5.tar.gz hadoop:/windows/</code></pre></li><li><p>解压压缩包</p><pre><code>$ tar -zxf /windows/hadoop-2.8.5.tar.gz -C /usr/local</code></pre></li><li><p>进入安装目录</p><pre><code>$ cd /usr/local/</code></pre></li><li><p>修改文件名</p><pre><code>$ mv ./hadoop-2.8.5 ./hadoop</code></pre></li><li><p>执行文件查看版本信息</p><p>先进入hadoop目录，然后执行下列语句</p><pre><code>$ ./bin/hadoop version</code></pre><p>会出现以下信息则说明安装成功</p><pre><code>Hadoop 2.8.5Subversion https://git-wip-us.apache.org/repos/asf/hadoop.git -r 0b8464d75227fcee2c6e7f2410377b3d53d3d5f8Compiled by jdu on 2018-09-10T03:32ZCompiled with protoc 2.5.0From source with checksum 9942ca5c745417c14e318835f420733This command was run using /usr/local/hadoop/share/hadoop/common/hadoop-common-2.8.5.jar</code></pre></li></ol><h2 id="6-Hadoop-伪分布式配置"><a href="#6-Hadoop-伪分布式配置" class="headerlink" title="6. Hadoop 伪分布式配置"></a>6. Hadoop 伪分布式配置</h2><ol><li><p>修改Hadoop的配置文件</p><ol><li><p>core-site.xml</p><p>进入<code>/usr/local/hadoop/etc/hadoop/</code></p><pre><code>$ cd /usr/local/hadoop/etc/hadoop$ vim core-site.xml</code></pre><p>将其中的</p><pre><code>&lt;configuration&gt;&lt;/configuration&gt;</code></pre><p>修改为</p><pre><code>&lt;configuration&gt;        &lt;property&gt;                &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;                                                       &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt;                &lt;description&gt;Abase for other temporary directories.&lt;/description&gt;        &lt;/property&gt;                                                                       &lt;property&gt;                &lt;name&gt;fs.defaultFS&lt;/name&gt;                &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;        &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>保存退出</p></li><li><p>hdfs-site.xml</p><p>同样在<code>configuratio</code> 标签修改为</p><pre><code>&lt;configuration&gt;        &lt;property&gt;                &lt;name&gt;dfs.replication&lt;/name&gt;                &lt;value&gt;1&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;                &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;                &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt;        &lt;/property&gt;&lt;/configuration&gt;</code></pre></li></ol></li><li><p>执行<code>NAMENode</code>的格式化</p><pre><code>$ cd /usr/local/hadoop$ ./bin/hdfs namenode -format</code></pre><p>成功会显示</p><pre><code>Exitting with status 0”</code></pre></li><li><p>开启<code>NameNode</code>和<code>DataNode</code>守护进程</p><pre><code>$ cd /usr/local/hadoop$ ./sbin/start-dfs.sh</code></pre></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>都9102年了，你还只会用python爬虫吗？</title>
    <link href="/2019/12/03/9102%E7%88%AC%E8%99%AB/"/>
    <url>/2019/12/03/9102%E7%88%AC%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="都9102年了，你还只会用python爬虫吗？"><a href="#都9102年了，你还只会用python爬虫吗？" class="headerlink" title="都9102年了，你还只会用python爬虫吗？"></a>都9102年了，你还只会用python爬虫吗？</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>无聊的时候，我们总会打开豆瓣电影榜，从上到下刷着电影，仿佛那些经典台词马上就在我们耳边响起，如《肖申克的救赎》中：生活可以归结为一种简单的选择：不是忙于生存，就是赶着去死；《霸王别姬》中：说的是一辈子！差一年，一个月，一天，一个时辰，都不算一辈子！但是，豆瓣电影那么多，还有那么多页，一页一页的找岂不是太费时间了，今天我就来从前端的角度来爬取豆瓣电影榜top250的首页。<a href="https://movie.douban.com/top250" target="_blank" rel="noopener">豆瓣top250</a>  </p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-获取豆瓣首页的html"><a href="#1-获取豆瓣首页的html" class="headerlink" title="1. 获取豆瓣首页的html"></a>1. 获取豆瓣首页的html</h3><p>由于我们需要向豆瓣的服务器发送一个请求来得到豆瓣首页的html代码，请求与响应在网络传输中需要一定的时间，而后续的操作需要在这个响应的基础上进行，因此，我们需要将主函数定义为异步的。以上实现需要引入下面两个包(注意：request 是对等依赖，需要与request-promise 分开安装）  </p><pre><code class="javascript">    npm i request    npm i request-promise  </code></pre><pre><code class="javascript">    let request = require(&#39;request-promise&#39;)    const main = async() =&gt; {      let html = await request({        url: &#39;https://movie.douban.com/top250&#39;      })      console.log(html)    }    main();</code></pre><h3 id="2-对html结构分析"><a href="#2-对html结构分析" class="headerlink" title="2.对html结构分析"></a>2.对html结构分析</h3><p>这样，我们就得到了豆瓣首页的html代码，但是我们需要的只是很少的一部分信息，所以我们要对其中的信息进行提取，因此我们引入一个npm包cheerio来提取html 特定选择器中的文本内容   </p><pre><code class="javascript">    npm i cherrio  </code></pre><p>然后在第二行引入</p><pre><code class="javascript">    let cheerio = require(&#39;cheerio&#39;);</code></pre><p>接下来我们要做的就是利用cheerio 将得到的html文本载入内存构建DOM，并使用选择器对目标标签中的文本进行提取，因此我们需要分析豆瓣首页的html结构</p><p><img src="./content.png" srcset="/img/loading.gif" alt="alt content"><br>content中是我们需要的内容，gird-16-8 用于设置主体内容的布局，article是电影项的主体部分，我们需要的内容就在其中，aside 置于网页右侧放置醒目信息，extra用于清除两端浮动。现在让我们进入article中看看   </p><p><img src="./article.png" srcset="/img/loading.gif" alt="alt article"><br>我们可以看到是一个典型的head,body,foot结构<br>opt mod   内放置一个复选框，用于用户选择根据条件筛选<br>grid_view  提取内容的主体<br>paginator  页尾的分页导航<br>进入grid_view，我们所需要的内容都放置在一个一个的列表中,列表中的每一个item都是一个我们需要提取的一部电影。     </p><h3 id="3-使用选择器得到需要的内容"><a href="#3-使用选择器得到需要的内容" class="headerlink" title="3.使用选择器得到需要的内容"></a>3.使用选择器得到需要的内容</h3><p>根据上面我们对结构的分析，我们就可以使用下列语句得到我们选择器内的每一个item</p><pre><code class="javascript">let movieNodes = $(&#39;#content .article .grid_view&#39;).find(&#39;.item&#39;);</code></pre><p>然后我们对保存了所有item的这样一个数组遍历，将其中每一项的关键值提取出来并保存，选择器的构建方法与上述的item获得的方法一致</p><pre><code class="javascript">let movies = [];for (let i = 0; i &lt; movieNodes.length; i++) {    let $ = cheerio.load(movieNodes[i]);    let titles = $(&#39;.info .hd span&#39;);    titles = ([]).map.call(titles, t =&gt; $(t).text());    let bd = $(&#39;.info .bd&#39;);    let info = bd.find(&#39;p&#39;).text();    let score = bd.find(&#39;.star .rating_num&#39;).text();    movies.push({      &#39;titles&#39;: titles,      &#39;info&#39;: info,      &#39;score&#39;: score    })  }</code></pre><p>不同的是，由于.hd 的选择器下面有四个span,因此我们得到的是一个对象数组，我们不能直接进行提取否则会出现对象循环引用的错误，我们先使用map对空数组的每一个元素进行映射，然后再通过改变this指针，使用选择器对空数组中每一个元素进行赋值。然后将提取出来的每一个字段append到数组中。</p><h3 id="4-文件保存"><a href="#4-文件保存" class="headerlink" title="4.文件保存"></a>4.文件保存</h3><p>接下来，我们在第三行加上</p><pre><code class="javascript">let fs = require(&#39;fs&#39;);</code></pre><blockquote><blockquote><p>在for循环的外面继续补充</p></blockquote></blockquote><pre><code class="javascript">fs.writeFile(&#39;./mainjs.json&#39;, JSON.stringify(movies), &#39;utf-8&#39;, (err) =&gt; {    if (err)      console.log(&#39;写入失败&#39;);    else      console.log(&#39;写入成功&#39;);  });</code></pre><p>就可以将我们刚刚在存在数组中的数据以json格式写入文件中啦，打开这个文件就会发现豆瓣top250的首页内容就存到了这个文件中，我们就可以挑选自己喜欢的电影观看了。<br>现在，让我们回过头来看看豆瓣top250首页的页面结构  </p><p><img src="./douban.jpg" srcset="/img/loading.gif" alt="body"><br>body豆瓣的首页由100%的body占据，body又分为上中下三部分，每个版块又按照一定的功能再划分为相应的子模块，直到划分为一个最小的模块为止，每一个模块占据网页的一定位置，实现某一个特定的功能，每个模块之间互不干扰。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对豆瓣的爬取，我们知道了，如果一个网站的结构带有一定规律，并有良好的可读性，会让我们的爬取更加简单，相反，如果一个网站乱糟糟的，毫无章法可言，那么这样的网站简直就是灾难。因此，我们在今后的编程中，应当多看看一些大型网站的html代码，学习其中的结构设计和命名规范。然后我们可以使用<a href="http://getbem.com/" target="_blank" rel="noopener">BEM</a>(Block Element Modifier)命名规范，对每一个模块使用合适的选择器，这样不仅提高了代码的可重用行，也利于网站的管理和维护。 </p><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><p>暑假闲来无事看了点python视频，虽然已经忘得都差不多了，但是用了node爬取了一次，又让我又拾起的对python的热情，于是一番折腾，查了相关文档，终于给捣鼓出来了，毕竟，生命在于折腾嘛！<br>以下是python的爬虫方式,基本思路与上述爬虫方式类似，只是对数据处理的语法上有所差异：<br>需要安转requests和beautifulsoup4模块</p><pre><code>pip install requestspip install beautifulsoup4</code></pre><pre><code class="python">import requestsfrom bs4 import BeautifulSoupimport jsondef gettext(x):     return x.get_text()#设置请求头伪装header = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36&#39;}# 先使用requests发送网络请求从而获取网页html = requests.get(&#39;https://movie.douban.com/top250&#39;, headers=header)# print(html.status_code)# 传入html构建DOMsoup=BeautifulSoup(html.content,&#39;html.parser&#39;)movieNodes = soup.find(&#39;ol&#39;, attrs={&#39;class&#39;: &#39;grid_view&#39;})movies=[]for movie in movieNodes.find_all(&#39;li&#39;):    title=movie.find(&#39;div&#39;,attrs={&#39;class&#39;:&#39;hd&#39;})    titles=title.find_all(&#39;span&#39;)    titles1=map(gettext,titles)    tit=[]    for ti in titles1:      tit.append(ti)    info=movie.find(&#39;p&#39;).get_text()    score=movie.find(&#39;span&#39;,attrs={&#39;class&#39;:&#39;rating_num&#39;}).get_text()    movies.append({      &quot;titles&quot;: tit,      &quot;info&quot;: info,      &quot;score&quot;: score    })f = open(&quot;mainpy.json&quot;, &quot;w&quot;, encoding=&#39;utf-8&#39;)json.dump(movies, f, ensure_ascii=False)f.close()</code></pre><p>写的时候遇到了以下这些小问题</p><ol><li>爬取豆瓣首页时，打印不出来html源码，查了一下才想起来是豆瓣做了反爬措施，需要伪装一下请求头信息。所以以后我们在爬取网站的时候可以先打印一下状态码status_code，如果显示418就说明被屏蔽了，显示200就说明请求成功。</li><li>使用find_all时，返回的是一个object数组，需要使用map方法提取出item 中每一个span的内容，然后添加到数组中去。map方法的使用可以查看相关的文档，里面有对每一个参数具体说明。</li><li>写文件的时候，报错说不能写入一个list,必须写入一个字符串，然后我将这个数组转成字符串写入文件，结果里面对转义字符没有进行转义，多了’\xa0’,’\n’ 等，查了一下发现这个玩意儿’\xa0’竟然就是html中的’&amp;nbsp’,然后我就用replace把每一个这个字符给删掉，结果存是存进去了，文件全爆红色，对比了mainjs.json才发现，保存的文件mainpy.json不是一个Json类型的数据，然后又是一顿度娘，发现有个专门写json文件的api,json.dump()，然后我replace直接也不用写了，不过需要引入json库….<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2>可能有时候写程序就是这样，出一个问题然后你就去解决这个问题，然后又出现另外的问题，你又得想怎么去解决新出现的问题，然后一直一直….结果发现直接使用一个api就好了…但是写程序注重的是过程，bug是我们编程道路上的补品，我们不能做一个apier，不是吗？</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim</title>
    <link href="/2018/03/03/Vim/"/>
    <url>/2018/03/03/Vim/</url>
    
    <content type="html"><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h2 id="1-vim的三种模式"><a href="#1-vim的三种模式" class="headerlink" title="1.vim的三种模式"></a>1.vim的三种模式</h2><h2 id="2-命令模式"><a href="#2-命令模式" class="headerlink" title="2.命令模式"></a>2.命令模式</h2><ol><li>按 <code>Esc</code>进入命令模式</li></ol><h2 id="3-插入模式"><a href="#3-插入模式" class="headerlink" title="3.插入模式"></a>3.插入模式</h2><p>进入插入模式的几种方法</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>i</td><td>在光标左侧插入</td></tr><tr><td>I</td><td>在光标所在行首插入</td></tr><tr><td>a</td><td>在光标右侧插入</td></tr><tr><td>A</td><td>在行尾插入</td></tr><tr><td>o</td><td>在光标所在行下方插入新的一行</td></tr><tr><td>O</td><td>在光标所在行的上方插入新的一行</td></tr></tbody></table><h2 id="4-底线插入模式"><a href="#4-底线插入模式" class="headerlink" title="4.底线插入模式"></a>4.底线插入模式</h2><p>命令模式下输入<code>:</code>进入</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>:wq</td><td>保存并退出</td></tr><tr><td>:w</td><td>保存不退出</td></tr><tr><td>:q</td><td>退出编辑</td></tr><tr><td>:q!</td><td>强制退出,不保存文件,</td></tr><tr><td>ZZ</td><td>保存文件,退出编辑</td></tr></tbody></table><h2 id="5-命令模式下各命令的具体作用"><a href="#5-命令模式下各命令的具体作用" class="headerlink" title="5.命令模式下各命令的具体作用"></a>5.命令模式下各命令的具体作用</h2><h3 id="5-1文本修改"><a href="#5-1文本修改" class="headerlink" title="5.1文本修改"></a>5.1文本修改</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>x</td><td>删除光标位置字符</td></tr><tr><td>dd</td><td>删除所在行</td></tr><tr><td>u</td><td>撤销最近修改</td></tr><tr><td>U</td><td>撤销当前行上的所有修改</td></tr><tr><td>r</td><td>替换光标位置上的一个字符</td></tr><tr><td>.</td><td>重复上一次的修改</td></tr></tbody></table><h3 id="5-2光标移动"><a href="#5-2光标移动" class="headerlink" title="5.2光标移动"></a>5.2光标移动</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>h</td><td>光标左移</td></tr><tr><td>j</td><td>光标下移</td></tr><tr><td>k</td><td>光标上移</td></tr><tr><td>l</td><td>光标右移</td></tr><tr><td>0(零)</td><td>光标移动到当前行行首</td></tr><tr><td>$</td><td>光标移动到当前行行尾</td></tr><tr><td>w</td><td>光标右移一个字</td></tr><tr><td>b</td><td>光标左移一个字</td></tr><tr><td>e</td><td>光标移到字尾</td></tr><tr><td>[Enter]</td><td>光标移动到下一行行首</td></tr><tr><td>[Space]</td><td>光标右移一位</td></tr><tr><td>[Backspace]</td><td>光标左移一位</td></tr></tbody></table><h3 id="5-3复制与粘贴"><a href="#5-3复制与粘贴" class="headerlink" title="5.3复制与粘贴"></a>5.3复制与粘贴</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>v</td><td>进入visual,选中文本</td></tr><tr><td>d</td><td>删除选中文本并复制到缓冲区</td></tr><tr><td>y</td><td>将选中文本并复制到缓冲区</td></tr><tr><td>p</td><td>将指定缓冲区的内容放到当前光标的位置右侧</td></tr><tr><td>P</td><td>将指定缓冲区的内容放到当前光标的位置左侧</td></tr></tbody></table><h3 id="5-4翻页"><a href="#5-4翻页" class="headerlink" title="5.4翻页"></a>5.4翻页</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>[ctrl+d]</td><td>将光标向下移到文件尾，通常每次移动12行</td></tr><tr><td>[ctrl+u]</td><td>将光标向上移到文件头，通常每次移动12行</td></tr><tr><td>[ctrl+f]</td><td>将光标向下移到文件尾，通常每次移动24行</td></tr><tr><td>[ctrl+b]</td><td>将光标向上移到文件头，通常每次移动24行</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
